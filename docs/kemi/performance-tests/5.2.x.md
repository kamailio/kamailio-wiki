# KEMI Performances For v5.2.0

The tests were using Kamailio v5.2.0 just before release (Nov 2018). The
focus was on comparing native execution time for **request_route**
versus its equivalent **ksr_request_route()** for REGISTER processing.
Note that the tests were not focusing in getting the maximum capacity of
processing for Kamailio, but to discover the difference in execution
time between native configuration file and equivalent KEMI scripts.

## Testing Ecosystem

- server: Intel NUC 7i7DNHE; CPU: I7-8650U @ 1.90GHz; CPU Cores: 4;
    CPU Threads: 8; Memory: 16GB
- operating system: Debian Testing
- ip address: 192.168.178.98
- sip tool: sipp

## SIPP Scenario

File: REGISTER_client.xml

``` xml
<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE scenario SYSTEM "sipp.dtd">

<!-- This program is free software; you can redistribute it and/or      -->
<!-- modify it under the terms of the GNU General Public License as     -->
<!-- published by the Free Software Foundation; either version 2 of the -->
<!-- License, or (at your option) any later version.                    -->
<!--                                                                    -->
<!-- This program is distributed in the hope that it will be useful,    -->
<!-- but WITHOUT ANY WARRANTY; without even the implied warranty of     -->
<!-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      -->
<!-- GNU General Public License for more details.                       -->
<!--                                                                    -->
<!-- You should have received a copy of the GNU General Public License  -->
<!-- along with this program; if not, write to the                      -->
<!-- Free Software Foundation, Inc.,                                    -->
<!-- 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA             -->
<!--                                                                    -->
<!--                 Sipp default 'uac' scenario.                       -->
<!--                                                                    -->

<scenario name="Basic Sipstone UAC">
  <!-- In client mode (sipp placing calls), the Call-ID MUST be         -->
  <!-- generated by sipp. To do so, use [call_id] keyword.                -->

  <send retrans="500">
    <![CDATA[
      REGISTER sip:[remote_ip]:[remote_port] SIP/2.0
      Via: SIP/2.0/[transport] [local_ip]:[local_port];branch=[branch]
      From: [field0] <sip:[field0]@[remote_ip]:[local_port]>;tag=[pid]SIPpTag00[call_number]
      To: [service] <sip:[field0]@[remote_ip]:[remote_port]>
      Call-ID: [call_id]
      CSeq: 1 REGISTER
      Contact: <sip:[field0]@[local_ip]:[local_port]>
      Max-Forwards: 70
      Subject: Performance Test
      Content-Type: application/sdp
      Content-Length: [len]
    ]]>
  </send>

  <recv response="401" auth="true" rtd="true">
  </recv>

  <send retrans="500">
    <![CDATA[
      REGISTER sip:[remote_ip]:[remote_port] SIP/2.0
      Via: SIP/2.0/[transport] [local_ip]:[local_port];branch=[branch]
      From: [field0] <sip:[field0]@[remote_ip]:[local_port]>;tag=[pid]SIPpTag00[call_number]
      To: [service] <sip:[field0]@[remote_ip]:[remote_port]>
      Call-ID: [call_id]
      CSeq: 1 REGISTER
      Contact: <sip:[field1]@[local_ip]:[local_port]>
      Max-Forwards: 70
      [field2]
      Subject: Performance Test
      Content-Type: application/sdp
      Content-Length: [len]
    ]]>
  </send>

  <recv response="200">
  </recv>

  <!-- definition of the response time repartition table (unit is ms)   -->
  <ResponseTimeRepartition value="10, 20, 30, 40, 50, 100, 150, 200"/>

  <!-- definition of the call length repartition table (unit is ms)     -->
  <CallLengthRepartition value="10, 50, 100, 500, 1000, 5000, 10000"/>

</scenario>

```

Testing input file REGISTER_client.csv:

```
SEQUENTIAL
test0;192.168.178.98;[authentication username=test0 password=test0];
test1;192.168.178.98;[authentication username=test1 password=test1];
test2;192.168.178.98;[authentication username=test2 password=test2];
test3;192.168.178.98;[authentication username=test3 password=test3];
test4;192.168.178.98;[authentication username=test4 password=test4];
test5;192.168.178.98;[authentication username=test5 password=test5];
test6;192.168.178.98;[authentication username=test6 password=test6];
test7;192.168.178.98;[authentication username=test7 password=test7];
test8;192.168.178.98;[authentication username=test8 password=test8];
test9;192.168.178.98;[authentication username=test9 password=test9];
```

These users have to be added to Kamailio subscriber table. To add them
from the source code tree of Kamailio:

```shell
cd utils/kamctl/
DBENGINE=MYSQL ./kamdbctl create
DBENGINE=MYSQL ./kamctl add test0@127.0.0.1 test0
DBENGINE=MYSQL ./kamctl add test1@127.0.0.1 test1
DBENGINE=MYSQL ./kamctl add test2@127.0.0.1 test2
DBENGINE=MYSQL ./kamctl add test3@127.0.0.1 test3
DBENGINE=MYSQL ./kamctl add test4@127.0.0.1 test4
DBENGINE=MYSQL ./kamctl add test5@127.0.0.1 test5
DBENGINE=MYSQL ./kamctl add test6@127.0.0.1 test6
DBENGINE=MYSQL ./kamctl add test7@127.0.0.1 test7
DBENGINE=MYSQL ./kamctl add test8@127.0.0.1 test8
DBENGINE=MYSQL ./kamctl add test9@127.0.0.1 test9
DBENGINE=MYSQL ./kamctl db show subscriber
```

## SIPP Testing Command

SIPP was run on the same system with Kamailio. The command is:

```
sipp 192.168.178.98 -sf REGISTER_client.xml -inf REGISTER_client.csv -trace_msg -trace_err -l 1000 -r 4000 -m 20000
```

## Kamailio Details

Kamailio was run from source tree, after compilation, with the
configuration files places in the folder **../etc/**.

Configuration files are presented in the next sections.

### Common Config File

File: ../etc/kamailio-basic-kemi.cfg

``` c
#!KAMAILIO
#
# Kamailio (OpenSER) SIP Server v5.3 - default configuration script
#     - web: http://www.kamailio.org
#     - git: http://sip-router.org
#
# Direct your questions about this file to: <sr-users@lists.kamailio.org>
#
# Refer to the Core CookBook at http://www.kamailio.org/wiki/
# for an explanation of possible statements, functions and parameters.
#
# Several features can be enabled using '#!define WITH_FEATURE' directives:
#
# *** To run in debug mode:
#     - define WITH_DEBUG
#
# *** To enable mysql:
#     - define WITH_MYSQL
#
# *** To enable authentication execute:
#     - enable mysql
#     - define WITH_AUTH
#     - add users using 'kamctl'
#
# *** To enable IP authentication execute:
#     - enable mysql
#     - enable authentication
#     - define WITH_IPAUTH
#     - add IP addresses with group id '1' to 'address' table
#
# *** To enable persistent user location execute:
#     - enable mysql
#     - define WITH_USRLOCDB
#
# *** To enable nat traversal execute:
#     - define WITH_NAT
#     - install RTPProxy: http://www.rtpproxy.org
#     - start RTPProxy:
#        rtpproxy -l _your_public_ip_ -s udp:localhost:7722
#     - option for NAT SIP OPTIONS keepalives: WITH_NATSIPPING
#
# *** To enable TLS support execute:
#     - adjust CFGDIR/tls.cfg as needed
#     - define WITH_TLS
#
# *** To enhance accounting execute:
#     - enable mysql
#     - define WITH_ACCDB
#     - add following columns to database
#!ifdef ACCDB_COMMENT
  ALTER TABLE acc ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN src_ip varchar(64) NOT NULL default '';
  ALTER TABLE acc ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_ip varchar(64) NOT NULL default '';
  ALTER TABLE missed_calls ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT '';
#!endif

#!define WITH_MYSQL
#!define WITH_AUTH
#!define WITH_IPAUTH
#!define WITH_USRLOCDB
#!define WITH_NAT
#!define WITH_ANTIFLOOD
#!define WITH_ACCDB

####### Include Local Config If Exists #########
import_file "kamailio-local.cfg"

####### Defined Values #########

# *** Value defines - IDs used later in config
#!ifdef WITH_MYSQL
# - database URL - used to connect to database server by modules such
#       as: auth_db, acc, usrloc, a.s.o.
#!ifndef DBURL
#!define DBURL "mysql://kamailio:kamailiorw@localhost/kamailio"
#!endif
#!endif
#!define MULTIDOMAIN 0

# - flags
#   FLT_ - per transaction (message) flags
#   FLB_ - per branch flags
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5

#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

####### Global Parameters #########

### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
#!ifdef WITH_DEBUG
debug=4
log_stderror=yes
#!else
debug=2
log_stderror=no
#!endif

memdbg=5
memlog=5

#!ifdef WITH_CFGLUA
log_prefix="LUA {$rm}: "
#!else
#!ifdef WITH_CFGPYTHON
log_prefix="PYT {$rm}: "
#!else
log_prefix="NAT {$rm}: "
#!endif
#!endif

latency_cfg_log=2

log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

fork=yes
children=16

/* uncomment the next line to disable TCP (default on) */
#disable_tcp=yes

/* uncomment the next line to disable the auto discovery of local aliases
 * based on reverse DNS on IPs (default on) */
#auto_aliases=no

/* add local domain aliases */
#alias="sip.mydomain.com"

/* uncomment and configure the following line if you want Kamailio to
 * bind on a specific interface/port/proto (default bind on all available) */
#listen=udp:10.0.0.10:5060

/* port to listen to
 * - can be specified more than once if needed to listen on many ports */
port=5060

#!ifdef WITH_TLS
enable_tls=yes
#!endif

# life time of TCP connection when there is no traffic
# - a bit higher than registration expires to cope with UA behind NAT
tcp_connection_lifetime=3605

####### Modules Section ########

/* set paths to location of modules (to sources or installation folders) */
# mpath="/usr/local/lib/kamailio/modules/"

#!ifdef WITH_MYSQL
loadmodule "db_mysql.so"
#!endif

loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"

#!ifdef WITH_AUTH
loadmodule "auth.so"
loadmodule "auth_db.so"
#!ifdef WITH_IPAUTH
loadmodule "permissions.so"
#!endif
#!endif

#!ifdef WITH_NAT
loadmodule "nathelper.so"
loadmodule "rtpproxy.so"
#!endif

#!ifdef WITH_TLS
loadmodule "tls.so"
#!endif

#!ifdef WITH_DEBUG
loadmodule "debugger.so"
#!endif

#!ifdef WITH_ANTIFLOOD
loadmodule "htable.so"
loadmodule "pike.so"
#!endif

#!ifdef WITH_CFGLUA
loadmodule "app_lua.so"
#!endif

#!ifdef WITH_CFGPYTHON
loadmodule "app_python.so"
#!endif

#!ifdef WITH_CFGJSDT
loadmodule "app_jsdt.so"
#!endif

#!ifdef WITH_CFGSQLANG
loadmodule "app_sqlang.so"
#!endif

# ----------------- setting module-specific parameters ---------------

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
/* set the path to RPC fifo control file */
# modparam("jsonrpcs", "fifo_name", "/var/run/kamailio/kamailio_rpc.fifo")
/* set the path to RPC unix socket control file */
# modparam("jsonrpcs", "dgram_socket", "/var/run/kamailio/kamailio_rpc.sock")

# ----- ctl params -----
#modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")

# ----- tm params -----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 30sec
modparam("tm", "fr_timer", 30000)
# default invite retransmission timeout after 1xx: 120sec
modparam("tm", "fr_inv_timer", 120000)


# ----- rr params -----
# add value to ;lr param to cope with most of the UAs
modparam("rr", "enable_full_lr", 1)
# do not append from tag to the RR (no need for this script)
modparam("rr", "append_fromtag", 0)


# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
/* uncomment the next line to disable parallel forking via location */
# modparam("registrar", "append_branches", 0)
/* uncomment the next line not to allow more than 10 contacts per AOR */
#modparam("registrar", "max_contacts", 10)
# max value for expires of registrations
modparam("registrar", "max_expires", 3600)
# set it to 1 to enable GRUU
modparam("registrar", "gruu_enabled", 0)


# ----- acc params -----
/* what special events should be accounted ? */
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
/* by default we do not adjust the direct of the sequential requests.
 * if you enable this parameter, be sure the enable "append_fromtag"
 * in "rr" module */
modparam("acc", "detect_direction", 0)
/* account triggers (flags) */
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra",
    "src_user=$fU;src_domain=$fd;src_ip=$si;"
    "dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
/* enhanced DB accounting */
#!ifdef WITH_ACCDB
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "db_url", DBURL)
modparam("acc", "db_extra",
    "src_user=$fU;src_domain=$fd;src_ip=$si;"
    "dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
#!endif


# ----- usrloc params -----
/* enable DB persistency for location entries */
modparam("usrloc", "preload", "location")
#!ifdef WITH_USRLOCDB
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "use_domain", MULTIDOMAIN)
#!endif


# ----- auth_db params -----
#!ifdef WITH_AUTH
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "")
modparam("auth_db", "use_domain", MULTIDOMAIN)

# ----- permissions params -----
#!ifdef WITH_IPAUTH
modparam("permissions", "db_url", DBURL)
modparam("permissions", "db_mode", 1)
#!endif

#!endif


#!ifdef WITH_NAT
# ----- rtpproxy params -----
modparam("rtpproxy", "rtpproxy_sock", "udp:127.0.0.1:7722")

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")

# params needed for NAT traversal in other modules
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")
modparam("usrloc", "nat_bflag", FLB_NATB)
#!endif


#!ifdef WITH_TLS
# ----- tls params -----
modparam("tls", "config", "/usr/local/etc/kamailio/tls.cfg")
#!endif

#!ifdef WITH_DEBUG
# ----- debugger params -----
modparam("debugger", "cfgtrace", 1)
#!endif

#!ifdef WITH_ANTIFLOOD
# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
#!endif

#!ifdef WITH_CFGPYTHON
modparam("app_python", "script_name", "../etc/kamailio-basic-kemi-python.py")
cfgengine "python"
#!else

#!ifdef WITH_CFGLUA
modparam("app_lua", "reload", 1)
modparam("app_lua", "load", "../etc/kamailio-basic-kemi-lua.lua")
cfgengine "lua"
#!else

#!ifdef WITH_CFGJSDT
modparam("app_jsdt", "load", "../etc/kamailio-basic-kemi-jsdt.js")
cfgengine "jsdt"
#!else
#!ifdef WITH_CFGSQLANG
modparam("app_sqlang", "load", "../etc/kamailio-basic-kemi-sqlang.sq")
cfgengine "sqlang"
#!else
cfgengine "native"
include_file "../etc/kamailio-basic-kemi-native.cfg"
#!endif

#!endif

#!endif

#!endif

```

### Native Scripting Routing Blocks

File: ../etc/kamailio-basic-kemi-native.cfg

``` c
####### Routing Logic ########


# Main SIP request routing logic
# - processing of any incoming SIP request starts with this route
# - note: this is the same as route { ... }
request_route {

    # per request initial checks
    route(REQINIT);

    sl_send_reply("100", "Trying");

    # NAT detection
    route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # handle requests within SIP dialogs
    route(WITHINDLG);

    ### only initial requests (no To tag)

    # handle retransmissions
    if(t_precheck_trans()) {
        t_check_trans();
        exit;
    }
    t_check_trans();

    # authentication
    route(AUTH);

    # record routing for dialog forming requests (in case they are routed)
    # - remove preloaded route headers
    remove_hf("Route");
    if (is_method("INVITE|SUBSCRIBE"))
        record_route();

    # account only INVITEs
    if (is_method("INVITE")) {
        setflag(FLT_ACC); # do accounting
    }

    # dispatch requests to foreign domains
    route(SIPOUT);

    ### requests for my local domains

    # handle registrations
    route(REGISTRAR);

    if ($rU==$null) {
        # request with no Username in RURI
        sl_send_reply("484","Address Incomplete");
        exit;
    }

    # user location service
    route(LOCATION);
}


route[RELAY] {
    # enable additional event routes for forwarded requests
    # - serial forking, RTP relaying handling, a.s.o.
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
    }
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    }
    if (is_method("INVITE")) {
        if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    }

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Per SIP request initial checks
route[REQINIT] {
#!ifdef WITH_ANTIFLOOD
    # flood dection from same IP and traffic ban for a while
    # be sure you exclude checking trusted peers, such as pstn gateways
    # - local host excluded (e.g., loop to self)
    if(src_ip!=myself) {
        if($sht(ipban=>$si)!=$null) {
            # ip is already blocked
            xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
            exit;
        }
        if (!pike_check_req()) {
            xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
            $sht(ipban=>$si) = 1;
            exit;
        }
    }
    if($ua =~ "friendly-scanner") {
        sl_send_reply("200", "OK");
        exit;
    }
#!endif

    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    if(is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200","Keepalive");
        exit;
    }

    if(!sanity_check("1511", "7")) {
        xlog("Malformed SIP message from $si:$sp\n");
        exit;
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) return;

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        route(DLGURI);
        if (is_method("BYE")) {
            setflag(FLT_ACC); # do accounting ...
            setflag(FLT_ACCFAILED); # ... even if the transaction fails
        }
        else if ( is_method("ACK") ) {
            # ACK is forwarded statelessly
            route(NATMANAGE);
        }
        else if ( is_method("NOTIFY") ) {
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            record_route();
        }
        route(RELAY);
        exit;
    }
    if ( is_method("ACK") ) {
        if ( t_check_trans() ) {
            # no loose-route, but stateful ACK;
            # must be an ACK after a 487
            # or e.g. 404 from upstream server
            route(RELAY);
            exit;
        } else {
            # ACK without matching transaction ... ignore and discard
            exit;
        }
    }
    sl_send_reply("404", "Not here");
    exit;
}

# Handle SIP registrations
route[REGISTRAR] {
    if (!is_method("REGISTER")) return;
    if(isflagset(FLT_NATS)) {
        setbflag(FLB_NATB);
#!ifdef WITH_NATSIPPING
        # do SIP NAT pinging
        setbflag(FLB_NATSIPPING);
#!endif
    }
    if (!save("location"))
        sl_reply_error();

    exit;
}

# User location service
route[LOCATION] {
    if (!lookup("location")) {
        $var(rc) = $rc;
        t_newtran();
        switch ($var(rc)) {
            case -1:
            case -3:
                send_reply("404", "Not Found");
                exit;
            case -2:
                send_reply("405", "Method Not Allowed");
                exit;
        }
    }

    # when routing via usrloc, log the missed calls also
    if (is_method("INVITE")) {
        setflag(FLT_ACCMISSED);
    }

    route(RELAY);
    exit;
}


# IP authorization and user uthentication
route[AUTH] {
#!ifdef WITH_AUTH

#!ifdef WITH_IPAUTH
    if((!is_method("REGISTER")) && allow_source_address()) {
        # source IP allowed
        return;
    }
#!endif

    if (is_method("REGISTER") || from_uri==myself) {
        # authenticate requests
        if (!auth_check("$fd", "subscriber", "1")) {
            auth_challenge("$fd", "0");
            exit;
        }
        # user authenticated - remove auth header
        if(!is_method("REGISTER|PUBLISH"))
            consume_credentials();
    }
    # if caller is not local subscriber, then check if it calls
    # a local destination, otherwise deny, not an open relay here
    if (from_uri!=myself && uri!=myself) {
        sl_send_reply("403","Not relaying");
        exit;
    }

#!endif
    return;
}

# Caller NAT detection
route[NATDETECT] {
#!ifdef WITH_NAT
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if(is_first_hop())
                set_contact_alias();
        }
        setflag(FLT_NATS);
    }
#!endif
    return;
}

# RTPProxy control
route[NATMANAGE] {
#!ifdef WITH_NAT
    if (is_request()) {
        if(has_totag()) {
            if(check_route_param("nat=yes")) {
                setbflag(FLB_NATB);
            }
        }
    }
    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB)))
        return;

    rtpproxy_manage("co");

    if (is_request()) {
        if (!has_totag()) {
            if(t_is_branch_route()) {
                add_rr_param(";nat=yes");
            }
        }
    }
    if (is_reply()) {
        if(isbflagset(FLB_NATB)) {
            set_contact_alias();
        }
    }
#!endif
    return;
}

# URI update for dialog requests
route[DLGURI] {
#!ifdef WITH_NAT
    if(!isdsturiset()) {
        handle_ruri_alias();
    }
#!endif
    return;
}

# Routing to foreign domains
route[SIPOUT] {
    if (uri==myself) return;

    append_hf("P-hint: outbound\r\n");
    route(RELAY);
    exit;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
    xdbg("new branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
    xdbg("incoming reply\n");
    if(status=~"[12][0-9][0-9]")
        route(NATMANAGE);
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
    route(NATMANAGE);

    if (t_is_canceled()) {
        exit;
    }
}

```

### Lua Scripting Routing Functions

File: ../etc/kamailio-basic-kemi-lua.lua

``` lua
-- Kamailio - equivalent of routing blocks in Lua
--
-- KSR - the new dynamic object exporting Kamailio functions (kemi)
-- sr - the old static object exporting Kamailio functions
--

-- Relevant remarks:
--  * do not execute Lua 'exit' - that will kill Lua interpreter which is
--  embedded in Kamailio, resulting in killing Kamailio
--  * use KSR.x.exit() to trigger the stop of executing the script
--  * KSR.drop() is only marking the SIP message for drop, but doesn't stop
--  the execution of the script. Use KSR.x.exit() after it or KSR.x.drop()
--


-- global variables corresponding to defined values (e.g., flags) in kamailio.cfg
FLT_ACC=1
FLT_ACCMISSED=2
FLT_ACCFAILED=3
FLT_NATS=5

FLB_NATB=6
FLB_NATSIPPING=7

-- global variables with common SIP attributes exposed by Kamailio
K_si = ""; -- source ip
K_su = ""; -- source address
K_fu = ""; -- from uri
K_fd = ""; -- from domain
K_rm = ""; -- request method
K_ua = ""; -- user agent

-- SIP request routing
-- equivalent of request_route{}
function ksr_request_route()

    ksr_set_sipvars();
    -- per request initial checks
    ksr_route_reqinit();

    KSR.sl.send_reply("100", "Trying");

    -- NAT detection
    ksr_route_natdetect();

    -- CANCEL processing
    if KSR.is_CANCEL() then
        if KSR.tm.t_check_trans()>0 then
            ksr_route_relay();
        end
        return 1;
    end

    -- handle requests within SIP dialogs
    ksr_route_withindlg();

    -- -- only initial requests (no To tag)

    -- handle retransmissions
    if KSR.tmx.t_precheck_trans()>0 then
        KSR.tm.t_check_trans();
        return 1;
    end
    if KSR.tm.t_check_trans()==0 then return 1 end

    -- authentication
    ksr_route_auth();

    -- record routing for dialog forming requests (in case they are routed)
    -- - remove preloaded route headers
    KSR.hdr.remove("Route");
    -- if INVITE or SUBSCRIBE
    if KSR.is_method_in("IS") then
        KSR.rr.record_route();
    end

    -- account only INVITEs
    if KSR.is_INVITE() then
        KSR.setflag(FLT_ACC); -- do accounting
    end

    -- dispatch requests to foreign domains
    ksr_route_sipout();

    -- -- requests for my local domains

    -- handle registrations
    ksr_route_registrar();

    if KSR.corex.has_ruri_user() < 0 then
        -- request with no Username in RURI
        KSR.sl.sl_send_reply(484,"Address Incomplete");
        return 1;
    end

    -- user location service
    ksr_route_location();

    return 1;
end

-- wrapper around tm relay function
function ksr_route_relay()
    -- enable additional event routes for forwarded requests
    -- - serial forking, RTP relaying handling, a.s.o.
    if KSR.is_method_in("IBSU") then
        if KSR.tm.t_is_set("branch_route")<0 then
            KSR.tm.t_on_branch("ksr_branch_manage");
        end
    end
    if KSR.is_method_in("ISU") then
        if KSR.tm.t_is_set("onreply_route")<0 then
            KSR.tm.t_on_reply("ksr_onreply_manage");
        end
    end

    if KSR.is_INVITE() then
        if KSR.tm.t_is_set("failure_route")<0 then
            KSR.tm.t_on_failure("ksr_failure_manage");
        end
    end

    if KSR.tm.t_relay()<0 then
        KSR.sl.sl_reply_error();
    end
    KSR.x.exit();
end


-- Per SIP request initial checks
function ksr_route_reqinit()
    if not KSR.is_myself_srcip() then
        if KSR.htable.sht_has_name("ipban", "eq", K_si) > 0 then
            -- ip is already blocked
            KSR.dbg("request from blocked IP - " .. K_rm
                    .. " from " .. K_fu .. " (SRC:" .. K_su .. "\n");
            KSR.x.exit();
        end
        if KSR.pike.pike_check_req()<0 then
            KSR.err("ALERT: pike blocking " .. K_rm
                    .. " from " .. K_fu .. " (SRC:" .. K_su .. "\n");
            KSR.htable.sht_seti("ipban", K_si, 1);
            KSR.x.exit();
        end
    end
    if KSR.corex.has_user_agent() > 0 then
        if string.find(K_ua, "friendly-scanner")
                or string.find(K_ua, "sipcli") then
            KSR.sl.sl_send_reply(200, "OK");
            KSR.x.exit();
        end
    end

    if KSR.maxfwd.process_maxfwd(10) < 0 then
        KSR.sl.sl_send_reply(483,"Too Many Hops");
        KSR.x.exit();
    end

    if KSR.is_OPTIONS()
            and KSR.is_myself_ruri()
            and KSR.corex.has_ruri_user() < 0 then
        KSR.sl.sl_send_reply(200,"Keepalive");
        KSR.x.exit();
    end

    if KSR.sanity.sanity_check(1511, 7)<0 then
        KSR.err("Malformed SIP message from src addr: "
                .. K_su .."\n");
        KSR.x.exit();
    end

end


-- Handle requests within SIP dialogs
function ksr_route_withindlg()
    if KSR.siputils.has_totag()<0 then return 1; end

    -- sequential request withing a dialog should
    -- take the path determined by record-routing
    if KSR.rr.loose_route()>0 then
        ksr_route_dlguri();
        if KSR.is_BYE() then
            KSR.setflag(FLT_ACC); -- do accounting ...
            KSR.setflag(FLT_ACCFAILED); -- ... even if the transaction fails
        elseif KSR.is_ACK() then
            -- ACK is forwarded statelessly
            ksr_route_natmanage();
        elseif  KSR.is_NOTIFY() then
            -- Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            KSR.rr.record_route();
        end
        ksr_route_relay();
        KSR.x.exit();
    end
    if KSR.is_ACK() then
        if KSR.tm.t_check_trans() >0 then
            -- no loose-route, but stateful ACK;
            -- must be an ACK after a 487
            -- or e.g. 404 from upstream server
            ksr_route_relay();
            KSR.x.exit();
        else
            -- ACK without matching transaction ... ignore and discard
            KSR.x.exit();
        end
    end
    KSR.sl.sl_send_reply(404, "Not here");
    KSR.x.exit();
end

-- Handle SIP registrations
function ksr_route_registrar()
    if not KSR.is_REGISTER() then return 1; end
    if KSR.isflagset(FLT_NATS) then
        KSR.setbflag(FLB_NATB);
        -- do SIP NAT pinging
        KSR.setbflag(FLB_NATSIPPING);
    end
    if KSR.registrar.save("location", 0)<0 then
        KSR.sl.sl_reply_error();
    end
    KSR.x.exit();
end

-- User location service
function ksr_route_location()
    local rc = KSR.registrar.lookup("location");
    if rc<0 then
        KSR.tm.t_newtran();
        if rc==-1 or rc==-3 then
            KSR.sl.send_reply("404", "Not Found");
            KSR.x.exit();
        elseif rc==-2 then
            KSR.sl.send_reply("405", "Method Not Allowed");
            KSR.x.exit();
        end
    end

    -- when routing via usrloc, log the missed calls also
    if KSR.is_INVITE() then
        KSR.setflag(FLT_ACCMISSED);
    end

    ksr_route_relay();
    KSR.x.exit();
end


-- IP authorization and user uthentication
function ksr_route_auth()

    if not KSR.is_REGISTER() then
        if KSR.permissions.allow_source_address(1)>0 then
            -- source IP allowed
            return 1;
        end
    end

    if KSR.is_REGISTER() or KSR.is_myself_furi() then
        -- authenticate requests
        if KSR.auth_db.auth_check(K_fd, "subscriber", 1)<0 then
            KSR.auth.auth_challenge(K_fd, 0);
            KSR.x.exit();
        end
        -- user authenticated - remove auth header
        if not KSR.is_method_in("RP") then
            KSR.auth.consume_credentials();
        end
    end

    -- if caller is not local subscriber, then check if it calls
    -- a local destination, otherwise deny, not an open relay here
    if (not KSR.is_myself_furi())
            and (not KSR.is_myself_ruri()) then
        KSR.sl.sl_send_reply(403,"Not relaying");
        KSR.x.exit();
    end

    return 1;
end

-- Caller NAT detection
function ksr_route_natdetect()
    KSR.force_rport();
    if KSR.nathelper.nat_uac_test(19)>0 then
        if KSR.is_REGISTER() then
            KSR.nathelper.fix_nated_register();
        elseif KSR.siputils.is_first_hop()>0 then
            KSR.nathelper.set_contact_alias();
        end
        KSR.setflag(FLT_NATS);
    end
    return 1;
end

-- RTPProxy control
function ksr_route_natmanage()
    if KSR.siputils.is_request()>0 then
        if KSR.siputils.has_totag()>0 then
            if KSR.rr.check_route_param("nat=yes")>0 then
                KSR.setbflag(FLB_NATB);
            end
        end
    end
    if (not (KSR.isflagset(FLT_NATS) or KSR.isbflagset(FLB_NATB))) then
        return 1;
    end

    KSR.rtpproxy.rtpproxy_manage("co");

    if KSR.siputils.is_request()>0 then
        if KSR.siputils.has_totag()<0 then
            if KSR.tmx.t_is_branch_route()>0 then
                KSR.rr.add_rr_param(";nat=yes");
            end
        end
    end
    if KSR.siputils.is_reply()>0 then
        if KSR.isbflagset(FLB_NATB) then
            KSR.nathelper.set_contact_alias();
        end
    end
    return 1;
end

-- URI update for dialog requests
function ksr_route_dlguri()
    if not KSR.isdsturiset() then
        KSR.nathelper.handle_ruri_alias();
    end
    return 1;
end

-- Routing to foreign domains
function ksr_route_sipout()
    if KSR.is_myself_ruri() then return 1; end

    KSR.hdr.append("P-Hint: outbound\r\n");
    ksr_route_relay();
    KSR.x.exit();
end

-- Manage outgoing branches
-- equivalent of branch_route[...]{}
function ksr_branch_manage()
    KSR.dbg("new branch [".. KSR.pv.get("$T_branch_idx") .. "] to ".. KSR.pv.get("$ru") .. "\n");
    ksr_route_natmanage();
    return 1;
end

-- Manage incoming replies
-- equivalent of onreply_route[...]{}
function ksr_onreply_manage()
    KSR.dbg("incoming reply\n");
    local scode = KSR.pv.get("$rs");
    if scode>100 and scode<299 then
        ksr_route_natmanage();
    end
    return 1;
end

-- Manage failure routing cases
-- equivalent of failure_route[...]{}
function ksr_failure_manage()
    ksr_route_natmanage();

    if KSR.tm.t_is_canceled()>0 then
        return 1;
    end
    return 1;
end

-- SIP response handling
-- equivalent of reply_route{}
function ksr_reply_route()
    KSR.info("===== response - from kamailio lua script\n");
    return 1;
end

-- set common SIP attributes in global vars
function ksr_set_sipvars()
    K_si = KSR.pv.gete("$si");
    K_su = KSR.pv.gete("$su");
    K_fu = KSR.pv.gete("$fu");
    K_fd = KSR.pv.gete("$fd");
    K_rm = KSR.pv.gete("$rm");
    K_ua = KSR.pv.gete("$ua");
end

```

### Python Scripting Routing Functions

File: ../etc/kamailio-basic-kemi-python.py

``` python
## Kamailio - equivalent of routing blocks in Python
##
## KSR - the new dynamic object exporting Kamailio functions
## Router - the old object exporting Kamailio functions
##

## Relevant remarks:
##  * return code -255 is used to propagate the 'exit' behaviour to the
##  parent route block function. The alternative is to use the native
##  Python function os.exit() (or exit()) -- it throws an exception that
##  is caught by Kamailio and previents the stop of the interpreter.


import sys
import Router.Logger as Logger
import KSR as KSR

# global variables corresponding to defined values (e.g., flags) in kamailio.cfg
FLT_ACC=1
FLT_ACCMISSED=2
FLT_ACCFAILED=3
FLT_NATS=5

FLB_NATB=6
FLB_NATSIPPING=7


# global function to instantiate a kamailio class object
# -- executed when kamailio app_python module is initialized
def mod_init():
    KSR.info("===== from Python mod init\n");
    # dumpObj(KSR);
    return kamailio();


# -- {start defining kamailio class}
class kamailio:
    def __init__(self):
        KSR.info('===== kamailio.__init__\n');


    # executed when kamailio child processes are initialized
    def child_init(self, rank):
        KSR.info('===== kamailio.child_init(%d)\n' % rank);
        return 0;


    # SIP request routing
    # -- equivalent of request_route{}
    def ksr_request_route(self, msg):
        # KSR.info("===== request - from kamailio python script\n");
        # KSR.info("===== method [%s] r-uri [%s]\n" % (KSR.pv.get("$rm"),KSR.pv.get("$ru")));

        # per request initial checks
        if self.ksr_route_reqinit(msg)==-255 :
            return 1;

        # NAT detection
        if self.ksr_route_natdetect(msg)==-255 :
            return 1;

        # CANCEL processing
        if KSR.is_CANCEL() :
            if KSR.tm.t_check_trans()>0 :
                self.ksr_route_relay(msg);
            return 1;

        # handle requests within SIP dialogs
        if self.ksr_route_withindlg(msg)==-255 :
            return 1;

        # -- only initial requests (no To tag)

        # handle retransmissions
        if KSR.tmx.t_precheck_trans()>0 :
            KSR.tm.t_check_trans();
            return 1;

        if KSR.tm.t_check_trans()==0 :
            return 1;

        # authentication
        if self.ksr_route_auth(msg)==-255 :
            return 1

        # record routing for dialog forming requests (in case they are routed)
        # - remove preloaded route headers
        KSR.hdr.remove("Route");
        if KSR.is_method_in("IS") :
            KSR.rr.record_route();


        # account only INVITEs
        if KSR.pv.get("$rm")=="INVITE" :
            KSR.setflag(FLT_ACC); # do accounting


        # dispatch requests to foreign domains
        if self.ksr_route_sipout(msg)==-255 :
            return 1;

        # # requests for my local domains

        # handle registrations
        if self.ksr_route_registrar(msg)==-255 :
            return 1;

        if KSR.corex.has_ruri_user() < 0 :
            # request with no Username in RURI
            KSR.sl.sl_send_reply(484,"Address Incomplete");
            return 1;


        # user location service
        self.ksr_route_location(msg);

        return 1;


    # wrapper around tm relay function
    def ksr_route_relay(self, msg):
        # enable additional event routes for forwarded requests
        # - serial forking, RTP relaying handling, a.s.o.
        if KSR.is_method_in("IBSU") :
            if KSR.tm.t_is_set("branch_route")<0 :
                KSR.tm.t_on_branch("ksr_branch_manage");

        if KSR.is_method_in("ISU") :
            if KSR.tm.t_is_set("onreply_route")<0 :
                KSR.tm.t_on_reply("ksr_onreply_manage");

        if KSR.is_INVITE() :
            if KSR.tm.t_is_set("failure_route")<0 :
                KSR.tm.t_on_failure("ksr_failure_manage");

        if KSR.tm.t_relay()<0 :
            KSR.sl.sl_reply_error();

        return -255;


    # Per SIP request initial checks
    def ksr_route_reqinit(self, msg):
        if not KSR.is_myself(KSR.pv.get("$si")) :
            if not KSR.pv.is_null("$sht(ipban=>$si)") :
                # ip is already blocked
                KSR.dbg("request from blocked IP - " + KSR.pv.get("$rm")
                        + " from " + KSR.pv.get("$fu") + " (IP:"
                        + KSR.pv.get("$si") + ":" + str(KSR.pv.get("$sp")) + ")\n");
                return -255;

            if KSR.pike.pike_check_req()<0 :
                KSR.err("ALERT: pike blocking " + KSR.pv.get("$rm")
                        + " from " + KSR.pv.get("$fu") + " (IP:"
                        + KSR.pv.get("$si") + ":" + str(KSR.pv.get("$sp")) + ")\n");
                KSR.pv.seti("$sht(ipban=>$si)", 1);
                return -255;

        if KSR.corex.has_user_agent() > 0 :
            ua = KSR.pv.gete("$ua")
            if (ua.find("friendly-scanner")!=-1
                    or ua.find("sipcli")!=-1) :
                KSR.sl.sl_send_reply(200, "Processed");
                return -255;

        if KSR.maxfwd.process_maxfwd(10) < 0 :
            KSR.sl.sl_send_reply(483,"Too Many Hops");
            return -255;

        if (KSR.is_OPTIONS()
                and KSR.is_myself_ruri()
                and KSR.corex.has_ruri_user() < 0) :
            KSR.sl.sl_send_reply(200,"Keepalive");
            return -255;

        if KSR.sanity.sanity_check(1511, 7)<0 :
            KSR.err("Malformed SIP message from "
                    + KSR.pv.get("$si") + ":" + str(KSR.pv.get("$sp")) +"\n");
            return -255;


    # Handle requests within SIP dialogs
    def ksr_route_withindlg(self, msg):
        if KSR.siputils.has_totag()<0 :
            return 1;

        # sequential request withing a dialog should
        # take the path determined by record-routing
        if KSR.rr.loose_route()>0 :
            if self.ksr_route_dlguri(msg)==-255 :
                return -255;
            if KSR.is_BYE() :
                # do accounting ...
                KSR.setflag(FLT_ACC);
                # ... even if the transaction fails
                KSR.setflag(FLT_ACCFAILED);
            elif KSR.is_ACK() :
                # ACK is forwarded statelessly
                if self.ksr_route_natmanage(msg)==-255 :
                    return -255;
            elif KSR.is_NOTIFY() :
                # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
                KSR.rr.record_route();

            self.ksr_route_relay(msg);
            return -255;

        if KSR.is_ACK() :
            if KSR.tm.t_check_trans() >0 :
                # no loose-route, but stateful ACK;
                # must be an ACK after a 487
                # or e.g. 404 from upstream server
                self.ksr_route_relay(msg);
                return -255;
            else:
                # ACK without matching transaction ... ignore and discard
                return -255;

        KSR.sl.sl_send_reply(404, "Not here");
        return -255;


    # Handle SIP registrations
    def ksr_route_registrar(self, msg):
        if not KSR.is_REGISTER() :
            return 1;
        if KSR.isflagset(FLT_NATS) :
            KSR.setbflag(FLB_NATB);
            # do SIP NAT pinging
            KSR.setbflag(FLB_NATSIPPING);

        if KSR.registrar.save("location", 0)<0 :
            KSR.sl.sl_reply_error();

        return -255;


    # User location service
    def ksr_route_location(self, msg):
        rc = KSR.registrar.lookup("location");
        if rc<0 :
            KSR.tm.t_newtran();
            if rc==-1 or rc==-3 :
                KSR.sl.send_reply(404, "Not Found");
                return -255;
            elif rc==-2 :
                KSR.sl.send_reply(405, "Method Not Allowed");
                return -255;

        # when routing via usrloc, log the missed calls also
        if KSR.is_INVITE() :
            KSR.setflag(FLT_ACCMISSED);

        self.ksr_route_relay(msg);
        return -255;



    # IP authorization and user uthentication
    def ksr_route_auth(self, msg):

        if not KSR.is_REGISTER() :
            if KSR.permissions.allow_source_address(1)>0 :
                # source IP allowed
                return 1;

        if KSR.is_REGISTER() or KSR.is_myself_furi() :
            # authenticate requests
            if KSR.auth_db.auth_check(KSR.pv.get("$fd"), "subscriber", 1)<0 :
                KSR.auth.auth_challenge(KSR.pv.get("$fd"), 0);
                return -255;

            # user authenticated - remove auth header
            if not KSR.is_method_in("RP") :
                KSR.auth.consume_credentials();

        # if caller is not local subscriber, then check if it calls
        # a local destination, otherwise deny, not an open relay here
        if (not KSR.is_myself_furi()) and (not KSR.is_myself_ruri()) :
            KSR.sl.sl_send_reply(403,"Not relaying");
            return -255;

        return 1;


    # Caller NAT detection
    def ksr_route_natdetect(self, msg):
        KSR.force_rport();
        if KSR.nathelper.nat_uac_test(19)>0 :
            if KSR.is_REGISTER() :
                KSR.nathelper.fix_nated_register();
            elif KSR.siputils.is_first_hop()>0 :
                KSR.nathelper.set_contact_alias();

            KSR.setflag(FLT_NATS);

        return 1;


    # RTPProxy control
    def ksr_route_natmanage(self, msg):
        if KSR.siputils.is_request()>0 :
            if KSR.siputils.has_totag()>0 :
                if KSR.rr.check_route_param("nat=yes")>0 :
                    KSR.setbflag(FLB_NATB);

        if (not (KSR.isflagset(FLT_NATS) or KSR.isbflagset(FLB_NATB))) :
            return 1;

        KSR.rtpproxy.rtpproxy_manage("co");

        if KSR.siputils.is_request()>0 :
            if not KSR.siputils.has_totag() :
                if KSR.tmx.t_is_branch_route()>0 :
                    KSR.rr.add_rr_param(";nat=yes");

        if KSR.siputils.is_reply()>0 :
            if KSR.isbflagset(FLB_NATB) :
                KSR.nathelper.set_contact_alias();

        return 1;


    # URI update for dialog requests
    def ksr_route_dlguri(self, msg):
        if not KSR.isdsturiset() :
            KSR.nathelper.handle_ruri_alias();

        return 1;


    # Routing to foreign domains
    def ksr_route_sipout(self, msg):
        if KSR.is_myself_ruri() :
            return 1;

        KSR.hdr.append("P-Hint: outbound\r\n");
        self.ksr_route_relay(msg);
        return -255;


    # Manage outgoing branches
    # -- equivalent of branch_route[...]{}
    def ksr_branch_manage(self, msg):
        KSR.dbg("new branch ["+ str(KSR.pv.get("$T_branch_idx")) "] to "+ KSR.pv.get("$ru") + "\n");
        self.ksr_route_natmanage(msg);
        return 1;


    # Manage incoming replies
    # -- equivalent of onreply_route[...]{}
    def ksr_onreply_manage(self, msg):
        KSR.dbg("incoming reply\n");
        scode = KSR.pv.get("$rs");
        if scode>100 and scode<299 :
            self.ksr_route_natmanage(msg);

        return 1;


    # Manage failure routing cases
    # -- equivalent of failure_route[...]{}
    def ksr_failure_manage(self, msg):
        if self.ksr_route_natmanage()==-255 : return 1;

        if KSR.tm.t_is_canceled()>0 :
            return 1;

        return 1;


    # SIP response handling
    # -- equivalent of reply_route{}
    def ksr_reply_route(self, msg):
        KSR.info("===== response - from kamailio python script\n");
        return 1;


# -- {end defining kamailio class}


# global helper function for debugging purposes
def dumpObj(obj):
    for attr in dir(obj):
        # KSR.info("obj.%s = %s\n" % (attr, getattr(obj, attr)));
        Logger.LM_INFO("obj.%s = %s\n" % (attr, getattr(obj, attr)));


```

### Kamailio Start Commands

Executed when running with native scripting language:

    ./src/kamailio -f ../etc/kamailio-basic-kemi.cfg -L src/modules/ -w . -a no -E -e -dd 2>&1 | tee /tmp/kamailio-register-native.txt

Executed when running with Lua scripting language:

    ./src/kamailio -f ../etc/kamailio-basic-kemi.cfg -L src/modules/ -w . -A WITH_CFGLUA -a no -E -e -dd 2>&1 | tee /tmp/kamailio-register-lua.txt

Executed when running with Python scripting language:

    ./src/kamailio -f ../etc/kamailio-basic-kemi.cfg -L src/modules/ -w . -A WITH_CFGPYTHON -a no -E -e -dd 2>&1 | tee /tmp/kamailio-register-python.txt

## Results

The following metrics are collected for each test:

- cnt - number of SIP messages processed (counter)
- sum - the sum of execution times for request_route or
    ksr_request_route() (microseconds)
- min - the minimum execution time for request_route or
    ksr_request_route() (microseconds)
- max - the maximum execution time for request_route or
    ksr_request_route() (microseconds)
- avg - the average execution time for request_route or
    ksr_request_route() (microseconds)

The metrics are extracted from the log messages using the next awk
script:

``` awk
BEGIN {
        sum = 0
        avg = 0
        min = 1000000
        max = 0
        cnt = 0
}

/request-route executed/ {
        sum += $(NF-1)
        cnt += 1
        if(min > $(NF-1)) {
                min = $(NF-1)
        }
        if(max < $(NF-1)) {
                max = $(NF-1)
        }
}

END {
        print "cnt: ", cnt
        print "sum: ", sum
        print "min: ", min
        print "max: ", max
        if(cnt>0) {
                avg = sum/cnt
        }
        print "avg: ", avg
}

```

The results of several iterations running the tests:

    $ awk -f kamailio-exec-report.awk /tmp/kamailio-register-native.txt
    cnt:  63157
    sum:  4748289
    min:  21
    max:  2028
    avg:  75.1823

    $ awk -f kamailio-exec-report.awk /tmp/kamailio-register-native.txt
    cnt:  63003
    sum:  4728507
    min:  21
    max:  1791
    avg:  75.0521

    $ awk -f kamailio-exec-report.awk /tmp/kamailio-register-native.txt
    cnt:  63564
    sum:  4918165
    min:  21
    max:  3226
    avg:  77.3734

    $ awk -f kamailio-exec-report.awk /tmp/kamailio-register-native.txt
    cnt:  62752
    sum:  4184315
    min:  17
    max:  1948
    avg:  66.6802

    $ awk -f kamailio-exec-report.awk /tmp/kamailio-register-native.txt
    cnt:  63616
    sum:  4255858
    min:  17
    max:  1619
    avg:  66.8992

    $ awk -f kamailio-exec-report.awk /tmp/kamailio-register-native.txt
    cnt:  62420
    sum:  3697635
    min:  17
    max:  2144
    avg:  59.238

    $ awk -f kamailio-exec-report.awk /tmp/kamailio-register-native.txt
    cnt:  63595
    sum:  4426750
    min:  17
    max:  3456
    avg:  69.6085

    $ awk -f kamailio-exec-report.awk /tmp/kamailio-register-lua.txt
    cnt:  61080
    sum:  4203512
    min:  26
    max:  1316
    avg:  68.8198

    $ awk -f kamailio-exec-report.awk /tmp/kamailio-register-lua.txt
    cnt:  61006
    sum:  4852005
    min:  25
    max:  2535
    avg:  79.5332

    $ awk -f kamailio-exec-report.awk /tmp/kamailio-register-lua.txt
    cnt:  60567
    sum:  4099683
    min:  26
    max:  2159
    avg:  67.6884

    $ awk -f kamailio-exec-report.awk /tmp/kamailio-register-lua.txt
    cnt:  61850
    sum:  4466376
    min:  23
    max:  2110
    avg:  72.213

    $ awk -f kamailio-exec-report.awk /tmp/kamailio-register-lua.txt
    cnt:  61197
    sum:  3844555
    min:  22
    max:  1852
    avg:  62.8226

    $ awk -f kamailio-exec-report.awk /tmp/kamailio-register-lua.txt
    cnt:  61445
    sum:  4202427
    min:  23
    max:  1750
    avg:  68.3933

    $ awk -f kamailio-exec-report.awk /tmp/kamailio-register-lua.txt
    cnt:  61103
    sum:  4248753
    min:  23
    max:  2442
    avg:  69.5343

    $ awk -f kamailio-exec-report.awk /tmp/kamailio-register-python.txt
    cnt:  60846
    sum:  4432028
    min:  22
    max:  2628
    avg:  72.8401

    $ awk -f kamailio-exec-report.awk /tmp/kamailio-register-python.txt
    cnt:  61031
    sum:  4353501
    min:  23
    max:  3005
    avg:  71.3326

    $ awk -f kamailio-exec-report.awk /tmp/kamailio-register-python.txt
    cnt:  60785
    sum:  4400362
    min:  20
    max:  2093
    avg:  72.3922

    $ awk -f kamailio-exec-report.awk /tmp/kamailio-register-python.txt
    cnt:  60836
    sum:  4427855
    min:  23
    max:  3441
    avg:  72.7835

    $ awk -f kamailio-exec-report.awk /tmp/kamailio-register-python.txt
    cnt:  60813
    sum:  4591943
    min:  20
    max:  1751
    avg:  75.5092

## Remarks

Mentioning it again, the target of the tests was not to measure the
capacity of Kamailio processing, but how the execution time differs in
more or less same conditions between native scripting configuration file
and KEMI alternatives, so far being done for Lua and Python scripting.

Testing was done on the same system, running first the test with native
configuration file and immediately after, the one for Lua or Python
scripting.

It was observed that the execution of native scripting routing blocks
and Lua scripting functions takes more or less same time. Sometimes is
native scripting slightly faster, other times is Lua scripting slightly
faster. The average (for both native and Lua scripts) is in the range of
60 to 80 microseconds ( 1 / 1 000 000 of a second) for processing the
registration request. The minimum reflects more what it takes for the
first REGISTER request without authorization header, which is quickly
challenged with 401 response. The maximum reflect the processing of the
REGISTER request with valid authorization header, which does a query to
database to fetch the password as well as store/update the record in the
location hash table (writing to database on timer - usrloc db_mode 2).

There are variable number of retransmissions, being the reason for
having cnt higher than 60000, a matter of sipp being able to match the
response with the request at this high pace of stress testing (4 000
registrations per second, with a limit of 10 000 transactions at the
same time, stopping after 20 000 sent messages). Note that each
registration is challenged for authentication, so it is resent with
authorization header.

Comparing with the state of KEMI exports for version 5.1.x, in the
v5.2.x were introduced some functions to be the equivalent of some
conditions done with core keywords.

For example, in the native scripting:

``` c
if(uri == myself)
```

can be done in a KEMI scripting language with:

``` lua
if KSR.is_myself_ruri() then
```

Tests for Python (using app_python module) were done couple of days
later (the Debian Testing system was upgraded to latest version of
packages). It was a pleasant surprise to see that the execution times
were in the same range as for native and Lua routing scripts.

The plan is to as run Lua tests using LuaJIT interpreter instead of the
standard Lua (support for LuaJIT was also added for v5.2.x) as well as
test for other KEMI itnerpreters (JavaScript, Ruby, Squirrel...).
